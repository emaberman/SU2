diff --git a/Common/include/CConfig.hpp b/Common/include/CConfig.hpp
index cca0a9f71f..7f2ab7caaf 100644
--- a/Common/include/CConfig.hpp
+++ b/Common/include/CConfig.hpp
@@ -4651,7 +4651,8 @@ public:
    * \brief Get whether to use "Mmatrix Jacobians" for Scalar Upwind scheme.
    * \return yes/no.
    */
-  bool GetMmatrixTurbJacobian (void) const { return MmatrixTurbJac; }
+  bool 
+  GetMmatrixTurbJacobian (void) const { return MmatrixTurbJac; }
 
   /*!
    * \brief Get the kind of integration scheme (explicit or implicit)
diff --git a/Common/include/linear_algebra/CSysMatrix.hpp b/Common/include/linear_algebra/CSysMatrix.hpp
index 732de91e32..f698074c15 100644
--- a/Common/include/linear_algebra/CSysMatrix.hpp
+++ b/Common/include/linear_algebra/CSysMatrix.hpp
@@ -820,6 +820,29 @@ class CSysMatrix {
     for (iVar = 0; iVar < nVar; iVar++) matrix[index + iVar * (nVar + 1)] = PassiveAssign(val_matrix);
   }
 
+/*!
+   * \brief Adds positive values from vector block values to the diagonal of the (i, i) subblock
+   *        of the matrix-by-blocks structure.
+   * \param[in] block_i - Diagonal index.
+   * \param[in] val_block - vector Block to add to the diagonal of the matrix.
+   * \param[in] alpha - Scale factor.
+   */
+  
+  template <class OtherType, class T = ScalarType>
+  inline void AddPosVec2Diag(unsigned long block_i, const OtherType& val_block, T alpha = 1.0) {
+    auto index = dia_ptr[block_i] * nVar * nVar;
+    for (auto iVar = 0ul; iVar < nVar; iVar++)
+      matrix[index + iVar * (nVar + 1)] += PassiveAssign(max(alpha * val_block[iVar] ,0.0));
+  }
+
+  template <class OtherType, class T = ScalarType>
+  inline void AddPosVecDivBlock(unsigned long block_i, const OtherType& val_block, const OtherType& alpha ) {
+    auto index = dia_ptr[block_i] * nVar * nVar;
+    for (auto iVar = 0ul; iVar < nVar; iVar++){
+      matrix[index + iVar * (nVar + 1)] += PassiveAssign( max(val_block[iVar]/(alpha[iVar]+1e-20) ,0.0));
+    }
+  }
+
   /*!
    * \brief Deletes the values of the row i of the sparse matrix.
    * \param[in] i - Index of the row.
diff --git a/Common/include/linear_algebra/CSysVector.hpp b/Common/include/linear_algebra/CSysVector.hpp
index 42b249b11c..48c5264bfe 100644
--- a/Common/include/linear_algebra/CSysVector.hpp
+++ b/Common/include/linear_algebra/CSysVector.hpp
@@ -396,6 +396,40 @@ class CSysVector : public VecExpr::CVecExpr<CSysVector<ScalarType>, ScalarType>
     AddBlock(jPoint, block, -alpha);
   }
 
+  /*!
+   * \brief Set diaganol of matrix as "block" to the vector.
+   * \note Template param Overwrite can be set to false to update existing values.
+   * \param[in] iPoint - index of the point where set the residual.
+   * \param[in] block - Value to set to the residual.
+   * \param[in] alpha - Scale factor (axpy-type operation).
+   */
+  template <class MatrixType, bool Overwrite = true>
+  FORCEINLINE void SetMatDiag(unsigned long iPoint, const MatrixType& block, ScalarType alpha = 1) {
+    if (Overwrite) {
+      for (auto i = 0ul; i < nVar; ++i) vec_val[iPoint * nVar + i] = alpha * block[i][i];
+    } else {
+      for (auto i = 0ul; i < nVar; ++i) vec_val[iPoint * nVar + i] += alpha * block[i][i];
+    }
+  }
+
+  /*!
+   * \brief Add diaganol of matrix as "block" to the vector, see SetMatDiagBlock.
+   */
+  template <class MatrixType>
+  FORCEINLINE void AddMatDiag(unsigned long iPoint, const MatrixType& block, ScalarType alpha = 1) {
+    SetMatDiag<MatrixType, false>(iPoint, block, alpha);
+  }
+
+  /*!
+   * \brief Add to iPoint, subtract from jPoint.
+   */
+  template <class MatrixType>
+  FORCEINLINE void UpdateMatDiagBlocks(unsigned long iPoint, unsigned long jPoint, const MatrixType& block,
+                                ScalarType alpha = 1) {
+    AddMatDiag(iPoint, block, alpha);
+    AddMatDiag(jPoint, block, -alpha);
+  }
+
   /*!
    * \brief Vectorized version of SetBlock, sets multiple iPoint's.
    * \param[in] iPoint - SIMD integer, the positions to update.
diff --git a/Common/src/CConfig.cpp b/Common/src/CConfig.cpp
index 6e9c26116e..98f5aeaf26 100644
--- a/Common/src/CConfig.cpp
+++ b/Common/src/CConfig.cpp
@@ -1998,7 +1998,7 @@ void CConfig::SetConfig_Options() {
    *  \n DESCRIPTION: Convective numerical method \ingroup Config*/
   addConvectOption("CONV_NUM_METHOD_TURB", Kind_ConvNumScheme_Turb, Kind_Centered_Turb, Kind_Upwind_Turb);
 /*!\brief Mmatrix \n DESCRIPTION: Check if the M-matrix should be used for scalar upwind scheme \ingroup Config*/
-  addBoolOption("TURB_M_MATRIX_JAC", MmatrixTurbJac, false);
+  addBoolOption("MMATRIX_TURB_JAC", MmatrixTurbJac, false);
   
 
   /*!\brief MUSCL_ADJTURB \n DESCRIPTION: Check if the MUSCL scheme should be used \ingroup Config*/
diff --git a/SU2_CFD/include/numerics/CNumerics.hpp b/SU2_CFD/include/numerics/CNumerics.hpp
index 2e45916edb..5e1cabc3e9 100644
--- a/SU2_CFD/include/numerics/CNumerics.hpp
+++ b/SU2_CFD/include/numerics/CNumerics.hpp
@@ -203,11 +203,15 @@ public:
     const Vector_t residual;
     const Matrix_t jacobian_i;
     const Matrix_t jacobian_j;
-
+    const Vector_t diagCorrect; 
+    
     ResidualType() = delete;
 
     ResidualType(const Vector_t& res, const Matrix_t& jac_i, const Matrix_t& jac_j) :
-      residual(res), jacobian_i(jac_i), jacobian_j(jac_j) { }
+      residual(res), jacobian_i(jac_i), jacobian_j(jac_j), diagCorrect(nullptr) { }
+
+    ResidualType(const Vector_t& res, const Matrix_t& jac_i, const Matrix_t& jac_j, const Vector_t& d_cor) :
+      residual(res), jacobian_i(jac_i), jacobian_j(jac_j), diagCorrect(d_cor) { }
 
     /*!
      * \brief The object can be directly cast to the vector type, this
@@ -658,6 +662,7 @@ public:
                                                         bool correct,
                                                         const Vec2& var_i, const Vec2& var_j,
                                                         su2double* projNormal,
+                                                        su2double* projTan,
                                                         su2double* projCorrected) {
     assert(nDim == 2 || nDim == 3);
     nDim = (nDim > 2)? 3 : 2;
@@ -681,8 +686,14 @@ public:
         if (correct) edgeProj += meanGrad * edgeVec[iDim];
       }
 
-      projCorrected[iVar] = projNormal[iVar];
-      if (correct) projCorrected[iVar] -= (edgeProj - (var_j[iVar]-var_i[iVar])) * proj_vector_ij;
+      // projCorrected[iVar] = projNormal[iVar];
+      // if (correct) projCorrected[iVar] -= (edgeProj - (var_j[iVar]-var_i[iVar])) * proj_vector_ij;
+      if (correct){
+        projTan[iVar] = projNormal[iVar]-edgeProj* proj_vector_ij;
+        projCorrected[iVar] = projTan[iVar]+ (var_j[iVar]-var_i[iVar]) * proj_vector_ij;;
+      } 
+      else projCorrected[iVar] = projNormal[iVar];
+ 
     }
 
     return proj_vector_ij;
diff --git a/SU2_CFD/include/numerics/scalar/scalar_diffusion.hpp b/SU2_CFD/include/numerics/scalar/scalar_diffusion.hpp
index 4e588c59d6..9d13df9a96 100644
--- a/SU2_CFD/include/numerics/scalar/scalar_diffusion.hpp
+++ b/SU2_CFD/include/numerics/scalar/scalar_diffusion.hpp
@@ -68,8 +68,10 @@ class CAvgGrad_Scalar : public CNumerics {
   su2double* Jacobian_i[MAXNVAR];             /*!< \brief Flux Jacobian w.r.t. node i. */
   su2double* Jacobian_j[MAXNVAR];             /*!< \brief Flux Jacobian w.r.t. node j. */
   su2double JacobianBuffer[2*MAXNVAR*MAXNVAR];/*!< \brief Static storage for the two Jacobians. */
+  su2double diagCorr[MAXNVAR];                /*!< \brief Static storage for a correction vector of the jacobian */
+  su2double ProjTanGrad[MAXNVAR];             /*!< \brief tangent component of Mean_gradScalarVar DOT normal, if required. */
 
-  const bool correct_gradient = false, incompressible = false;
+  const bool correct_gradient = false, incompressible = false, Mmatrix = false;
 
   /*!
    * \brief A pure virtual function; Adds any extra variables to AD
@@ -96,7 +98,8 @@ class CAvgGrad_Scalar : public CNumerics {
     : CNumerics(val_nDim, val_nVar, config),
       idx(val_nDim, config->GetnSpecies()),
       correct_gradient(correct_grad),
-      incompressible(config->GetKind_Regime() == ENUM_REGIME::INCOMPRESSIBLE) {
+      incompressible(config->GetKind_Regime() == ENUM_REGIME::INCOMPRESSIBLE),
+      Mmatrix(config -> GetMmatrixTurbJacobian()) {
     if (nVar > MAXNVAR) {
       SU2_MPI::Error("Static arrays are too small.", CURRENT_FUNCTION);
     }
@@ -143,13 +146,15 @@ class CAvgGrad_Scalar : public CNumerics {
 
     su2double ProjGradScalarVarNoCorr[MAXNVAR];
     proj_vector_ij = ComputeProjectedGradient(nDim, nVar, Normal, Coord_i, Coord_j, ScalarVar_Grad_i, ScalarVar_Grad_j,
-                                              correct_gradient, ScalarVar_i, ScalarVar_j, ProjGradScalarVarNoCorr,
+                                              correct_gradient, ScalarVar_i, ScalarVar_j, ProjGradScalarVarNoCorr, ProjTanGrad, 
                                               Proj_Mean_GradScalarVar);
     FinishResidualCalc(config);
 
     AD::SetPreaccOut(Flux, nVar);
     AD::EndPreacc();
-
-    return ResidualType<>(Flux, Jacobian_i, Jacobian_j);
+    
+    if (Mmatrix == true) return ResidualType<>(Flux, Jacobian_i, Jacobian_j, diagCorr);
+    else return ResidualType<>(Flux, Jacobian_i, Jacobian_j);
+    // return ResidualType<>(Flux, Jacobian_i, Jacobian_j);
   }
 };
diff --git a/SU2_CFD/include/numerics/turbulent/turb_diffusion.hpp b/SU2_CFD/include/numerics/turbulent/turb_diffusion.hpp
index 2cf4a66710..203504d531 100644
--- a/SU2_CFD/include/numerics/turbulent/turb_diffusion.hpp
+++ b/SU2_CFD/include/numerics/turbulent/turb_diffusion.hpp
@@ -48,6 +48,8 @@ private:
   using Base::Flux;
   using Base::Jacobian_i;
   using Base::Jacobian_j;
+  using Base::ProjTanGrad;
+  using Base::diagCorr;
 
   const su2double sigma = 2.0/3.0;
 
@@ -62,6 +64,8 @@ private:
    */
   void FinishResidualCalc(const CConfig* config) override {
     const bool implicit = config->GetKind_TimeIntScheme() == EULER_IMPLICIT;
+    const bool Mmatrix = config -> GetMmatrixTurbJacobian();
+    // const bool Mmatrix = false;
 
     /*--- Compute mean effective viscosity ---*/
 
@@ -74,8 +78,16 @@ private:
     /*--- For Jacobians -> Use of TSL approx. to compute derivatives of the gradients ---*/
 
     if (implicit) {
-      Jacobian_i[0][0] = (0.5*Proj_Mean_GradScalarVar[0]-nu_e*proj_vector_ij)/sigma;
-      Jacobian_j[0][0] = (0.5*Proj_Mean_GradScalarVar[0]+nu_e*proj_vector_ij)/sigma;
+      /*current default jacobian is not thin shear layer (TSL) approxiamtion, to be fixed later, for now branch: */
+      if (Mmatrix){
+        Jacobian_i[0][0] = (-nu_e*proj_vector_ij)/sigma;
+        Jacobian_j[0][0] = (+nu_e*proj_vector_ij)/sigma;
+        diagCorr[0]= nu_e*ProjTanGrad[0]/sigma;
+      }
+      else {
+        Jacobian_i[0][0] = (0.5*Proj_Mean_GradScalarVar[0]-nu_e*proj_vector_ij)/sigma;
+        Jacobian_j[0][0] = (0.5*Proj_Mean_GradScalarVar[0]+nu_e*proj_vector_ij)/sigma;
+      }
     }
   }
 
@@ -113,6 +125,8 @@ private:
   using Base::Flux;
   using Base::Jacobian_i;
   using Base::Jacobian_j;
+  using Base::ProjTanGrad;
+  using Base::diagCorr;
 
   const su2double sigma = 2.0/3.0;
   const su2double cn1 = 16.0;
@@ -128,7 +142,9 @@ private:
    */
   void FinishResidualCalc(const CConfig* config) override {
     const bool implicit = config->GetKind_TimeIntScheme() == EULER_IMPLICIT;
-
+    const bool Mmatrix = config -> GetMmatrixTurbJacobian();
+    // const bool Mmatrix = false;
+    
     /*--- Compute mean effective viscosity ---*/
 
     const su2double nu_i = Laminar_Viscosity_i/Density_i;
@@ -153,8 +169,16 @@ private:
     /*--- For Jacobians -> Use of TSL approx. to compute derivatives of the gradients ---*/
 
     if (implicit) {
+      /*current default jacobian is not thin layer approxiamtion, to be fixed later, for now branch: */
+      if (Mmatrix){
+        Jacobian_i[0][0] = (-nu_e*proj_vector_ij)/sigma;
+        Jacobian_j[0][0] = (+nu_e*proj_vector_ij)/sigma;
+        diagCorr[0]= nu_e*ProjTanGrad[0]/sigma;
+      }
+      else {
       Jacobian_i[0][0] = (0.5*Proj_Mean_GradScalarVar[0]-nu_e*proj_vector_ij)/sigma;
       Jacobian_j[0][0] = (0.5*Proj_Mean_GradScalarVar[0]+nu_e*proj_vector_ij)/sigma;
+      }
     }
   }
 
@@ -194,6 +218,9 @@ private:
   using Base::Flux;
   using Base::Jacobian_i;
   using Base::Jacobian_j;
+  using Base::ProjTanGrad;
+  using Base::diagCorr;
+
 
   const su2double sigma_k1; /*!< \brief Constants for the viscous terms, k-w (1), k-eps (2)*/
   const su2double sigma_k2;
@@ -215,7 +242,9 @@ private:
    */
   void FinishResidualCalc(const CConfig* config) override {
     const bool implicit = config->GetKind_TimeIntScheme() == EULER_IMPLICIT;
-
+    const bool Mmatrix = config -> GetMmatrixTurbJacobian();
+    // const bool Mmatrix = false;
+    
     /*--- Compute the blended constant for the viscous terms ---*/
     const su2double sigma_kine_i = F1_i*sigma_k1 + (1.0 - F1_i)*sigma_k2;
     const su2double sigma_kine_j = F1_j*sigma_k1 + (1.0 - F1_j)*sigma_k2;
@@ -243,6 +272,11 @@ private:
       const su2double proj_on_rho_j = proj_vector_ij/Density_j;
       Jacobian_j[0][0] = diff_kine*proj_on_rho_j;   Jacobian_j[0][1] = 0.0;
       Jacobian_j[1][0] = 0.0;                       Jacobian_j[1][1] = diff_omega*proj_on_rho_j;
+
+      if (Mmatrix){
+        diagCorr[0]= diff_kine*ProjTanGrad[0];
+        diagCorr[1]= diff_omega*ProjTanGrad[1];
+      }
     }
   }
 
diff --git a/SU2_CFD/include/numerics/turbulent/turb_sources.hpp b/SU2_CFD/include/numerics/turbulent/turb_sources.hpp
index 4e5f1cd51f..aed2d937ec 100644
--- a/SU2_CFD/include/numerics/turbulent/turb_sources.hpp
+++ b/SU2_CFD/include/numerics/turbulent/turb_sources.hpp
@@ -244,10 +244,22 @@ class CSourceBase_TurbSA : public CNumerics {
       }
 
       /*--- Compute production, destruction and cross production and jacobian ---*/
-      su2double Production = 0.0, Destruction = 0.0, CrossProduction = 0.0;
-      SourceTerms::get(ScalarVar_i[0], var, Production, Destruction, CrossProduction, Jacobian_i[0]);
+    //   su2double Production = 0.0, Destruction = 0.0, CrossProduction = 0.0;
+    //   SourceTerms::get(ScalarVar_i[0], var, Production, Destruction, CrossProduction, Jacobian_i[0]);
 
-      Residual = (Production - Destruction + CrossProduction) * Volume;
+    //   Residual = (Production - Destruction + CrossProduction) * Volume;
+
+      su2double Prod_hat = 0.0, Dest_hat = 0.0, CrossProduction = 0.0, jac_hat=0.0;
+      SourceTerms::get(ScalarVar_i[0], var, Prod_hat, Dest_hat, CrossProduction, jac_hat);
+
+      Residual = ((Prod_hat - Dest_hat)*ScalarVar_i[0] + CrossProduction) * Volume;
+      
+      /* Implicit part */
+      const bool Mmatrix = config -> GetMmatrixTurbJacobian();
+      // const bool Mmatrix = false;
+      
+      if (Mmatrix) Jacobian_i[0] +=  jac_hat+Prod_hat-Dest_hat; 
+      else Jacobian_i[0] +=  min(jac_hat, 0.0)+min(Prod_hat-Dest_hat,0.0);
 
       if (axisymmetric) ResidualAxisymmetricDiffusion(var.sigma);
       
@@ -432,74 +444,141 @@ struct Edw {
  * \param[out] cross_production: CrossProduction term.
  * \param[out] jacobian: Derivative of the combined source term wrt nue.
  */
+// struct SourceTerms {
+
+// /*! \brief Baseline (Original SA model). */
+// struct Bsl {
+//   static void get(const su2double& nue, const CSAVariables& var, su2double& production, su2double& destruction,
+//                   su2double& cross_production, su2double& jacobian) {
+//     ComputeProduction(nue, var, production, jacobian);
+//     ComputeDestruction(nue, var, destruction, jacobian);
+//     ComputeCrossProduction(nue, var, cross_production, jacobian);
+//   }
+
+//   static void ComputeProduction(const su2double& nue, const CSAVariables& var, su2double& production,
+//                                 su2double& jacobian) {
+//     const su2double factor = var.intermittency * var.cb1;
+//     production = factor * (1.0 - var.ft2) * var.Prod * nue;
+//     jacobian += factor * (-var.Prod * nue * var.d_ft2 + (1.0 - var.ft2) * (nue * var.d_Shat + var.Prod));
+//   }
+
+//   static void ComputeDestruction(const su2double& nue, const CSAVariables& var, su2double& destruction,
+//                                  su2double& jacobian) {
+//     const su2double cb1_k2 = var.cb1 / var.k2;
+//     const su2double factor = var.cw1 * var.fw - cb1_k2 * var.ft2;
+//     destruction = var.interDestrFactor * factor * pow(nue, 2) / var.dist_i_2;
+//     jacobian -= var.interDestrFactor * ((var.cw1 * var.d_fw - cb1_k2 * var.d_ft2) * pow(nue, 2) + factor * 2 * nue) / var.dist_i_2;
+//   }
+
+//   static void ComputeCrossProduction(const su2double& nue, const CSAVariables& var, su2double& cross_production,
+//                                      su2double&) {
+//     cross_production = var.cb2_sigma * var.norm2_Grad;
+//     /*--- No contribution to the jacobian. ---*/
+//   }
+// };
+
+// /*! \brief Negative. */
+// struct Neg {
+//   static void get(const su2double& nue, const CSAVariables& var, su2double& production, su2double& destruction,
+//                   su2double& cross_production, su2double& jacobian) {
+//     if (nue > 0.0) {
+//       Bsl::get(nue, var, production, destruction, cross_production, jacobian);
+//     } else {
+//       ComputeProduction(nue, var, production, jacobian);
+//       ComputeDestruction(nue, var, destruction, jacobian);
+//       ComputeCrossProduction(nue, var, cross_production, jacobian);
+//     }
+//   }
+
+//   static void ComputeProduction(const su2double& nue, const CSAVariables& var, su2double& production,
+//                                 su2double& jacobian) {
+//     const su2double dP_dnu = var.intermittency * var.cb1 * (1.0 - var.ct3) * var.Prod;
+//     production = dP_dnu * nue;
+//     jacobian += dP_dnu;
+//   }
+
+//   static void ComputeDestruction(const su2double& nue, const CSAVariables& var, su2double& destruction,
+//                                  su2double& jacobian) {
+//     /*--- The destruction when nue < 0 is added instead of the usual subtraction, hence the negative sign. ---*/
+//     const su2double dD_dnu = -var.cw1 * nue / var.dist_i_2;
+//     destruction = dD_dnu * nue * var.interDestrFactor;
+//     jacobian -= 2 * dD_dnu * var.interDestrFactor;
+//   }
+
+//   static void ComputeCrossProduction(const su2double& nue, const CSAVariables& var, su2double& cross_production,
+//                                      su2double& jacobian) {
+//     Bsl::ComputeCrossProduction(nue, var, cross_production, jacobian);
+//   }
+// };
+// };
+
 struct SourceTerms {
 
 /*! \brief Baseline (Original SA model). */
 struct Bsl {
-  static void get(const su2double& nue, const CSAVariables& var, su2double& production, su2double& destruction,
-                  su2double& cross_production, su2double& jacobian) {
-    ComputeProduction(nue, var, production, jacobian);
-    ComputeDestruction(nue, var, destruction, jacobian);
-    ComputeCrossProduction(nue, var, cross_production, jacobian);
+  static void get(const su2double& nue, const CSAVariables& var, su2double& Prod_hat, su2double& dest_hat,
+                  su2double& cross_production, su2double& jac_hat) {
+    ComputeProduction(nue, var, Prod_hat, jac_hat);
+    ComputeDestruction(nue, var, dest_hat, jac_hat);
+    ComputeCrossProduction(nue, var, cross_production, jac_hat);
   }
 
-  static void ComputeProduction(const su2double& nue, const CSAVariables& var, su2double& production,
-                                su2double& jacobian) {
+  static void ComputeProduction(const su2double& nue, const CSAVariables& var, su2double& Prod_hat,
+                                su2double& jac_hat) {
     const su2double factor = var.intermittency * var.cb1;
-    production = factor * (1.0 - var.ft2) * var.Prod * nue;
-    jacobian += factor * (-var.Prod * nue * var.d_ft2 + (1.0 - var.ft2) * (nue * var.d_Shat + var.Prod));
+    Prod_hat = factor * (1.0 - var.ft2) * var.Prod ;
+    jac_hat += factor * (-var.Prod * nue * var.d_ft2 + (1.0 - var.ft2) * (nue * var.d_Shat ));
   }
 
-  static void ComputeDestruction(const su2double& nue, const CSAVariables& var, su2double& destruction,
-                                 su2double& jacobian) {
+  static void ComputeDestruction(const su2double& nue, const CSAVariables& var, su2double& dest_hat,
+                                 su2double& jac_hat) {
     const su2double cb1_k2 = var.cb1 / var.k2;
     const su2double factor = var.cw1 * var.fw - cb1_k2 * var.ft2;
-    destruction = var.interDestrFactor * factor * pow(nue, 2) / var.dist_i_2;
-    jacobian -= var.interDestrFactor * ((var.cw1 * var.d_fw - cb1_k2 * var.d_ft2) * pow(nue, 2) + factor * 2 * nue) / var.dist_i_2;
+    dest_hat = var.interDestrFactor * factor * nue / var.dist_i_2;
+    jac_hat -= var.interDestrFactor * ((var.cw1 * var.d_fw - cb1_k2 * var.d_ft2) * pow(nue, 2) + factor * nue) / var.dist_i_2;
   }
 
   static void ComputeCrossProduction(const su2double& nue, const CSAVariables& var, su2double& cross_production,
                                      su2double&) {
     cross_production = var.cb2_sigma * var.norm2_Grad;
-    /*--- No contribution to the jacobian. ---*/
+    /*--- No contribution to the jac_hat. ---*/
   }
 };
 
 /*! \brief Negative. */
 struct Neg {
-  static void get(const su2double& nue, const CSAVariables& var, su2double& production, su2double& destruction,
-                  su2double& cross_production, su2double& jacobian) {
+  static void get(const su2double& nue, const CSAVariables& var, su2double& Prod_hat, su2double& dest_hat,
+                  su2double& cross_production, su2double& jac_hat) {
     if (nue > 0.0) {
-      Bsl::get(nue, var, production, destruction, cross_production, jacobian);
+      Bsl::get(nue, var, Prod_hat, dest_hat, cross_production, jac_hat);
     } else {
-      ComputeProduction(nue, var, production, jacobian);
-      ComputeDestruction(nue, var, destruction, jacobian);
-      ComputeCrossProduction(nue, var, cross_production, jacobian);
+      ComputeProduction(nue, var, Prod_hat, jac_hat);
+      ComputeDestruction(nue, var, dest_hat, jac_hat);
+      ComputeCrossProduction(nue, var, cross_production, jac_hat);
     }
   }
 
-  static void ComputeProduction(const su2double& nue, const CSAVariables& var, su2double& production,
-                                su2double& jacobian) {
+  static void ComputeProduction(const su2double& nue, const CSAVariables& var, su2double& Prod_hat,
+                                su2double& jac_hat) {
     const su2double dP_dnu = var.intermittency * var.cb1 * (1.0 - var.ct3) * var.Prod;
-    production = dP_dnu * nue;
-    jacobian += dP_dnu;
+    Prod_hat = dP_dnu ;
+    jac_hat += dP_dnu;
   }
 
-  static void ComputeDestruction(const su2double& nue, const CSAVariables& var, su2double& destruction,
-                                 su2double& jacobian) {
-    /*--- The destruction when nue < 0 is added instead of the usual subtraction, hence the negative sign. ---*/
+  static void ComputeDestruction(const su2double& nue, const CSAVariables& var, su2double& dest_hat,
+                                 su2double& jac_hat) {
+    /*--- The dest_hat when nue < 0 is added instead of the usual subtraction, hence the negative sign. ---*/
     const su2double dD_dnu = -var.cw1 * nue / var.dist_i_2;
-    destruction = dD_dnu * nue * var.interDestrFactor;
-    jacobian -= 2 * dD_dnu * var.interDestrFactor;
+    dest_hat = dD_dnu * var.interDestrFactor;
+    jac_hat -= 2 * dD_dnu * var.interDestrFactor;
   }
 
   static void ComputeCrossProduction(const su2double& nue, const CSAVariables& var, su2double& cross_production,
-                                     su2double& jacobian) {
-    Bsl::ComputeCrossProduction(nue, var, cross_production, jacobian);
+                                     su2double& jac_hat) {
+    Bsl::ComputeCrossProduction(nue, var, cross_production, jac_hat);
   }
 };
 };
-
 /* =============================================================================
  * SPALART-ALLMARAS ADDITIONAL SOURCE TERMS DECORATORS
  * ============================================================================*/
@@ -931,11 +1010,32 @@ class CSourcePieceWise_TurbSST final : public CNumerics {
       if (axisymmetric) ResidualAxisymmetricConvectionDiffusion(alfa_blended, zeta);
 
       /*--- Implicit part ---*/
+      
+    const bool Mmatrix = config -> GetMmatrixTurbJacobian();
+    // const bool Mmatrix = false;
 
+      
+      if (Mmatrix){
+        su2double rok = Density_i * ScalarVar_i[0];
+        su2double ik1   = -max(dk - pk,0.0) / rok;
+        su2double ik2   = -max(pk,0.) / rok;
+        
+        su2double row = Density_i * ScalarVar_i[1];
+        su2double iw1   = -max(dw - pw,0.0) / row;
+        su2double iw2   = -max(pw + dw,0.)/ row;
+
+        Jacobian_i[0][0] = (ik1 + ik2) * Volume;
+        Jacobian_i[0][1] = 0.0;
+        Jacobian_i[1][0] = 0.0;
+        Jacobian_i[1][1] = (iw1 + iw2) * Volume;
+      }
+
+      else{
       Jacobian_i[0][0] = -beta_star * ScalarVar_i[1] * Volume * (1.0 + zetaFMt);
       Jacobian_i[0][1] = -beta_star * ScalarVar_i[0] * Volume * (1.0 + zetaFMt);
       Jacobian_i[1][0] = 0.0;
       Jacobian_i[1][1] = -2.0 * beta_blended * ScalarVar_i[1] * Volume * (1.0 - 0.09/beta_blended * zetaFMt);
+      }
     }
 
     AD::SetPreaccOut(Residual, nVar);
diff --git a/SU2_CFD/include/solvers/CScalarSolver.hpp b/SU2_CFD/include/solvers/CScalarSolver.hpp
index 58aae7bb21..94ec2cbdae 100644
--- a/SU2_CFD/include/solvers/CScalarSolver.hpp
+++ b/SU2_CFD/include/solvers/CScalarSolver.hpp
@@ -80,6 +80,7 @@ class CScalarSolver : public CSolver {
 
 /*--- stability modification for M matrix Jacobian Diagonal  ---*/
   CSysVector<su2double> Diagonal_Sum;    /*!< \brief vector to store Diagonal of stability modification of implicit linear system. */
+  CSysVector<su2double> Diagonal_Sum_visc;    /*!< \brief vector to store Diagonal of stability modification of implicit linear system. */
   
   /*!
    * \brief The highest level in the variable hierarchy this solver can safely use.
@@ -106,6 +107,7 @@ class CScalarSolver : public CSolver {
                                          const CGeometry* geometry, CSolver** solver_container, CNumerics* numerics,
                                          const CConfig* config) {
     const bool implicit = (config->GetKind_TimeIntScheme() == EULER_IMPLICIT);
+    const bool Mmatrix = config->GetMmatrixTurbJacobian ();
     CFlowVariable* flowNodes = solver_container[FLOW_SOL] ?
         su2staticcast_p<CFlowVariable*>(solver_container[FLOW_SOL]->GetNodes()) : nullptr;
 
@@ -144,12 +146,20 @@ class CScalarSolver : public CSolver {
     } else {
       LinSysRes.SubtractBlock(iPoint, residual);
       LinSysRes.AddBlock(jPoint, residual);
-      if (implicit) Jacobian.UpdateBlocksSub(iEdge, iPoint, jPoint, residual.jacobian_i, residual.jacobian_j);
+      // if (implicit) Jacobian.UpdateBlocksSub(iEdge, iPoint, jPoint, residual.jacobian_i, residual.jacobian_j);
+      if (implicit){
+        Jacobian.UpdateBlocksSub(iEdge, iPoint, jPoint, residual.jacobian_i, residual.jacobian_j);
+        if (Mmatrix){
+        Diagonal_Sum_visc.AddBlock(iPoint, residual.diagCorrect);
+        Diagonal_Sum_visc.SubtractBlock(jPoint, residual.diagCorrect);
+        }
+      } 
     }
   }
 
   /*!
-   * \brief Generic implementation of the fluid interface boundary condition for scalar solvers.
+
+ * \brief Generic implementation of the fluid interface boundary condition for scalar solvers.  
    * \tparam SolverSpecificNumericsFunc - lambda that implements solver specific contributions to viscous numerics.
    * \note The functor has to implement (iPoint)
    * \param[in] geometry - Geometrical definition of the problem.
diff --git a/SU2_CFD/include/solvers/CScalarSolver.inl b/SU2_CFD/include/solvers/CScalarSolver.inl
index 55e6f0d544..cf50ca09f9 100644
--- a/SU2_CFD/include/solvers/CScalarSolver.inl
+++ b/SU2_CFD/include/solvers/CScalarSolver.inl
@@ -95,7 +95,9 @@ void CScalarSolver<VariableType>::CommonPreprocessing(CGeometry *geometry, const
   const bool muscl = config->GetMUSCL();
   const bool limiter = (config->GetKind_SlopeLimit() != LIMITER::NONE) &&
                        (config->GetInnerIter() <= config->GetLimiterIter());
-  const bool Mmatrix = config->GetMmatrixTurbJacobian ();
+  const bool Mmatrix = config -> GetMmatrixTurbJacobian();
+    // const bool Mmatrix = false;
+
   
 
   /*--- Clear residual and system matrix, not needed for
@@ -105,7 +107,8 @@ void CScalarSolver<VariableType>::CommonPreprocessing(CGeometry *geometry, const
     if (implicit) {
       Jacobian.SetValZero();
       if(Mmatrix){
-        Diagonal_Sum.SetValZero();  
+        Diagonal_Sum.SetValZero();
+        Diagonal_Sum_visc.SetValZero();  
       }
     } else {
       SU2_OMP_BARRIER
@@ -140,7 +143,9 @@ void CScalarSolver<VariableType>::Upwind_Residual(CGeometry* geometry, CSolver**
   const bool muscl = config->GetMUSCL();
   const bool limiter = (config->GetKind_SlopeLimit() != LIMITER::NONE) &&
                        (config->GetInnerIter() <= config->GetLimiterIter());
-  const bool Mmatrix = config->GetMmatrixTurbJacobian ();
+  const bool Mmatrix = config -> GetMmatrixTurbJacobian();
+  // const bool Mmatrix = false;
+
 
   /*--- Only reconstruct flow variables if MUSCL is on for flow (requires upwind) and turbulence. ---*/
   const bool musclFlow = config->GetMUSCL_Flow() && muscl && (config->GetKind_ConvNumScheme_Flow() == SPACE_UPWIND);
@@ -294,11 +299,12 @@ void CScalarSolver<VariableType>::Upwind_Residual(CGeometry* geometry, CSolver**
         if (implicit){
           if (Mmatrix){
             Jacobian.UpdateMMatrixBlocks(iEdge, iPoint, jPoint, residual.jacobian_i, residual.jacobian_j);
-            Diagonal_Sum.AddBlock(iPoint, *residual.jacobian_i);
-            Diagonal_Sum.AddBlock(iPoint, *residual.jacobian_j);
-            Diagonal_Sum.SubtractBlock(jPoint, *residual.jacobian_i);
-            Diagonal_Sum.SubtractBlock(jPoint, *residual.jacobian_j);
-            
+            // Diagonal_Sum.AddBlock(iPoint, *residual.jacobian_i);
+            // Diagonal_Sum.AddBlock(iPoint, *residual.jacobian_j);
+            // Diagonal_Sum.SubtractBlock(jPoint, *residual.jacobian_i);
+            // Diagonal_Sum.SubtractBlock(jPoint, *residual.jacobian_j);
+            Diagonal_Sum.UpdateMatDiagBlocks(iPoint, jPoint, residual.jacobian_i);
+            Diagonal_Sum.UpdateMatDiagBlocks(iPoint, jPoint, residual.jacobian_j);
             
 
           } else {
@@ -364,7 +370,9 @@ void CScalarSolver<VariableType>::Upwind_Residual(CGeometry* geometry, CSolver**
   if (Mmatrix) {
       SU2_OMP_FOR_STAT(omp_chunk_size)
       for (unsigned long iPoint = 0; iPoint < nPoint; ++iPoint) {
-        Jacobian.AddVal2Diag(iPoint, max(*Diagonal_Sum.GetBlock(iPoint),0.0));
+        // Jacobian.AddVal2Diag(iPoint, max(*Diagonal_Sum.GetBlock(iPoint),0.0));
+        Jacobian.AddPosVec2Diag(iPoint, Diagonal_Sum.GetBlock(iPoint));
+        Jacobian.AddPosVecDivBlock(iPoint, Diagonal_Sum_visc.GetBlock(iPoint), nodes->GetSolution(iPoint));
       }
       END_SU2_OMP_FOR
     }
diff --git a/SU2_CFD/src/numerics/radiation.cpp b/SU2_CFD/src/numerics/radiation.cpp
index 86a0793053..0452e026de 100644
--- a/SU2_CFD/src/numerics/radiation.cpp
+++ b/SU2_CFD/src/numerics/radiation.cpp
@@ -86,11 +86,11 @@ void CAvgGradCorrected_P1::ComputeResidual(su2double *val_residual, su2double **
   AD::SetPreaccIn(RadVar_i,nVar); AD::SetPreaccIn(RadVar_j,nVar);
   AD::SetPreaccIn(RadVar_Grad_i,nVar,nDim); AD::SetPreaccIn(RadVar_Grad_j,nVar,nDim);
 
-  su2double NormalGrad[nVar], CorrectedGrad[nVar];
+  su2double NormalGrad[nVar], CorrectedGrad[nVar], GradCorrection[nVar];
 
   auto proj_vector_ij = ComputeProjectedGradient(nDim, nVar, Normal, Coord_i, Coord_j, RadVar_Grad_i,
                                                  RadVar_Grad_j, true, RadVar_i, RadVar_j,
-                                                 NormalGrad, CorrectedGrad);
+                                                 NormalGrad, GradCorrection, CorrectedGrad);
 
   val_residual[0] = GammaP1*CorrectedGrad[0];
 
diff --git a/SU2_CFD/src/solvers/CTurbSASolver.cpp b/SU2_CFD/src/solvers/CTurbSASolver.cpp
index 2a7c71644f..bbea92fec7 100644
--- a/SU2_CFD/src/solvers/CTurbSASolver.cpp
+++ b/SU2_CFD/src/solvers/CTurbSASolver.cpp
@@ -76,7 +76,8 @@ CTurbSASolver::CTurbSASolver(CGeometry *geometry, CConfig *config, unsigned shor
 
     /*--- Initialization of the Stability Treatment ---*/
     if (Mmatrix)
-      Diagonal_Sum.Initialize(nPoint, nPointDomain, 1, 0.0);
+      Diagonal_Sum.Initialize(nPoint, nPointDomain, nVar, 0.0);
+      Diagonal_Sum_visc.Initialize(nPoint, nPointDomain, nVar, 0.0);
 
     if (ReducerStrategy)
       EdgeFluxes.Initialize(geometry->GetnEdge(), geometry->GetnEdge(), nVar, nullptr);
diff --git a/SU2_CFD/src/solvers/CTurbSSTSolver.cpp b/SU2_CFD/src/solvers/CTurbSSTSolver.cpp
index 29417e78c4..c9a9758964 100644
--- a/SU2_CFD/src/solvers/CTurbSSTSolver.cpp
+++ b/SU2_CFD/src/solvers/CTurbSSTSolver.cpp
@@ -80,7 +80,8 @@ CTurbSSTSolver::CTurbSSTSolver(CGeometry *geometry, CConfig *config, unsigned sh
       EdgeFluxes.Initialize(geometry->GetnEdge(), geometry->GetnEdge(), nVar, nullptr);
     
     if (Mmatrix)
-      Diagonal_Sum.Initialize(nPoint, nPointDomain, 1, 0.0);
+      Diagonal_Sum.Initialize(nPoint, nPointDomain, nVar, 0.0);
+      Diagonal_Sum_visc.Initialize(nPoint, nPointDomain, nVar, 0.0);
     
     /*--- Initialize the BGS residuals in multizone problems. ---*/
     if (multizone){
diff --git a/TestCases/rans/naca0012/turb_NACA0012_sa.cfg b/TestCases/rans/naca0012/turb_NACA0012_sa.cfg
index 59b285d9c8..e3883b75ac 100644
--- a/TestCases/rans/naca0012/turb_NACA0012_sa.cfg
+++ b/TestCases/rans/naca0012/turb_NACA0012_sa.cfg
@@ -77,6 +77,7 @@ MUSCL_TURB= YES
 SLOPE_LIMITER_TURB= NONE
 TIME_DISCRE_TURB= EULER_IMPLICIT
 CFL_REDUCTION_TURB= 1.0
+TURB_M_MATRIX_JAC=TRUE
 
 % --------------------------- CONVERGENCE PARAMETERS --------------------------%
 CONV_RESIDUAL_MINVAL= -12
